{"version":3,"sources":["../../src/util/pair-checker.js"],"names":["checkPair","context","left","right","Syntax","RuleError","report","getSource","helper","RuleHelper","isInParagraph","currentStrInParagraph","foundMissingPairNodes","foundLeft","matchParentheses","forEach","node","text","leftIndex","indexOf","push","index","pairIndex","pop","Paragraph","isChildNode","BlockQuote","Str","missingPairList","length"],"mappings":"AAAA;AACA;AACA;;;;;;;;;;;;;AAOA;;AACA;;;;AACO,SAASA,SAAT,CAAmBC,OAAnB,QAA6C;AAAA,MAAjB;AAAEC,IAAAA,IAAF;AAAQC,IAAAA;AAAR,GAAiB;AAChD,uBAAOD,IAAP;AACA,uBAAOC,KAAP;AACA,MAAI;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,SAAV;AAAqBC,IAAAA,MAArB;AAA6BC,IAAAA;AAA7B,MAA2CN,OAA/C;AACA,MAAIO,MAAM,GAAG,IAAIC,8BAAJ,CAAeR,OAAf,CAAb;AACA,MAAIS,aAAa,GAAG,KAApB;AACA,MAAIC,qBAAqB,GAAG,EAA5B;AACA;;;;;;AAKA,MAAMC,qBAAqB,GAAGD,qBAAqB,IAAI;AACnD,QAAIE,SAAS,GAAG,KAAhB;AACA,QAAIC,gBAAgB,GAAG,EAAvB;AACAH,IAAAA,qBAAqB,CAACI,OAAtB,CAA8BC,IAAI,IAAI;AAClC,UAAMC,IAAI,GAAGV,SAAS,CAACS,IAAD,CAAtB,CADkC,CAElC;;AACA,UAAIE,SAAS,GAAG,CAAC,CAAjB;;AACA,UAAI,CAACL,SAAL,EAAgB;AACZK,QAAAA,SAAS,GAAGD,IAAI,CAACE,OAAL,CAAajB,IAAb,CAAZ;;AACA,YAAIgB,SAAS,KAAK,CAAC,CAAnB,EAAsB;AAClBJ,UAAAA,gBAAgB,CAACM,IAAjB,CAAsB;AAClBJ,YAAAA,IADkB;AAElBK,YAAAA,KAAK,EAAEH;AAFW,WAAtB;AAIAL,UAAAA,SAAS,GAAG,IAAZ;AACH;AACJ,OAbiC,CAclC;;;AACA,UAAIS,SAAS,GAAGL,IAAI,CAACE,OAAL,CAAahB,KAAb,EAAoBe,SAAS,GAAG,CAAhC,CAAhB;;AACA,UAAII,SAAS,KAAK,CAAC,CAAnB,EAAsB;AAClBR,QAAAA,gBAAgB,CAACS,GAAjB;AACAV,QAAAA,SAAS,GAAG,KAAZ;AACH;AACJ,KApBD;AAqBA,WAAOC,gBAAP;AACH,GAzBD;;AA0BA,SAAO;AACH,KAACV,MAAM,CAACoB,SAAR,EAAmBR,IAAnB,EAAyB;AACrB,UAAIR,MAAM,CAACiB,WAAP,CAAmBT,IAAnB,EAAyB,CAACZ,MAAM,CAACsB,UAAR,CAAzB,CAAJ,EAAmD;AAC/C;AACH;;AACDf,MAAAA,qBAAqB,GAAG,EAAxB;AACAD,MAAAA,aAAa,GAAG,IAAhB;AACH,KAPE;;AAQH,KAACN,MAAM,CAACuB,GAAR,EAAaX,IAAb,EAAmB;AACf,UAAI,CAACN,aAAL,EAAoB;AAChB;AACH;;AACDC,MAAAA,qBAAqB,CAACS,IAAtB,CAA2BJ,IAA3B;AACH,KAbE;;AAcH,eAAIZ,MAAM,CAACoB,SAAX,cAA+B;AAC3B,UAAMI,eAAe,GAAGhB,qBAAqB,CAACD,qBAAD,CAA7C,CAD2B,CAE3B;;AACAD,MAAAA,aAAa,GAAG,KAAhB,CAH2B,CAI3B;;AACA,UAAIkB,eAAe,CAACC,MAAhB,KAA2B,CAA/B,EAAkC;AAC9B;AACH;;AACDD,MAAAA,eAAe,CAACb,OAAhB,CAAwB,WAAqB;AAAA,YAApB;AAAEC,UAAAA,IAAF;AAAQK,UAAAA;AAAR,SAAoB;AACzCf,QAAAA,MAAM,CACFU,IADE,EAEF,IAAIX,SAAJ,WAAiBH,IAAjB,2CAA6BC,KAA7B,mEAA8CD,IAA9C,SAAqDC,KAArD,GAA8D;AAC1DkB,UAAAA;AAD0D,SAA9D,CAFE,CAAN;AAMH,OAPD;AAQH;;AA9BE,GAAP;AAgCH","sourcesContent":["// LICENSE : MIT\n\"use strict\";\n/**\n * 「と」といったペアがちゃんと閉じられているかをチェックします\n * @param {object} context\n * @param {string} left\n * @param {string} right\n * @returns {object}\n */\nimport assert from \"assert\";\nimport { RuleHelper } from \"textlint-rule-helper\";\nexport function checkPair(context, { left, right }) {\n    assert(left);\n    assert(right);\n    let { Syntax, RuleError, report, getSource } = context;\n    let helper = new RuleHelper(context);\n    let isInParagraph = false;\n    let currentStrInParagraph = [];\n    /**\n     * `Str` nodeの配列を受け取り、pairが見つからないnodeを返す\n     * @param {Object} currentStrInParagraph\n     * @returns {{node, index}[]}\n     */\n    const foundMissingPairNodes = currentStrInParagraph => {\n        let foundLeft = false;\n        let matchParentheses = [];\n        currentStrInParagraph.forEach(node => {\n            const text = getSource(node);\n            // left を探す\n            let leftIndex = -1;\n            if (!foundLeft) {\n                leftIndex = text.indexOf(left);\n                if (leftIndex !== -1) {\n                    matchParentheses.push({\n                        node,\n                        index: leftIndex\n                    });\n                    foundLeft = true;\n                }\n            }\n            // right を探す\n            let pairIndex = text.indexOf(right, leftIndex + 1);\n            if (pairIndex !== -1) {\n                matchParentheses.pop();\n                foundLeft = false;\n            }\n        });\n        return matchParentheses;\n    };\n    return {\n        [Syntax.Paragraph](node) {\n            if (helper.isChildNode(node, [Syntax.BlockQuote])) {\n                return;\n            }\n            currentStrInParagraph = [];\n            isInParagraph = true;\n        },\n        [Syntax.Str](node) {\n            if (!isInParagraph) {\n                return;\n            }\n            currentStrInParagraph.push(node);\n        },\n        [`${Syntax.Paragraph}:exit`]() {\n            const missingPairList = foundMissingPairNodes(currentStrInParagraph);\n            // 探索おわり\n            isInParagraph = false;\n            // 全ての対が見つかったなら配列は空になる\n            if (missingPairList.length === 0) {\n                return;\n            }\n            missingPairList.forEach(({ node, index }) => {\n                report(\n                    node,\n                    new RuleError(`${left}の対となる${right}が見つかりません。${left}${right}`, {\n                        index\n                    })\n                );\n            });\n        }\n    };\n}\n"],"file":"pair-checker.js"}